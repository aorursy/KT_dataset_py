# Adding imports that will be used

import numpy as np # linear algebra
import pandas as pd # data processing, CSV file I/O (e.g. pd.read_csv)

# The following code takes all files in the given directory and print the paths of the files

import os
for dirname, _, filenames in os.walk('/kaggle/input'):
    for filename in filenames:
        print(os.path.join(dirname, filename))

# Definition of the tuples that will be read from the input files. These tuples of three positions represent the item index, its value and its weight
import sys
import csv
csv.field_size_limit(sys.maxsize)
from collections import namedtuple
Item = namedtuple("Item", ['index', 'value', 'weight'])
# This method checks that the solution is a valid solution. It is that the selected list of items does not weight more than the knapsack capacity
def check_solution(capacity, items, taken):
    weight = 0
    value = 0
    for item in items:
        if taken[item.index]== 1:
            weight += item.weight
            value += item.value
    if weight> capacity:
        print("soluci√≥n incorrecta, se supera la capacidad de la mochila (capacity, weight):", capacity, weight)
        return 0
    return value
# This function takes input data that describes a specific problem of TSP and solve it
def solve_it(input_data):
    # Modify this code to run your optimization algorithm
    # parse the input
    lines = input_data.split('\n')

    firstLine = lines[0].split()
    item_count = int(firstLine[0])
    capacity = int(firstLine[1])

    items = []

    for i in range(1, item_count+1):
        line = lines[i]
        parts = line.split()
        items.append(Item(i-1, int(parts[0]), int(parts[1])))

    # a trivial greedy algorithm for filling the knapsack
    # it takes items in-order until the knapsack is full
    value = 0
    weight = 0
    taken = [0]*len(items)

    for item in items:
        if weight + item.weight <= capacity:
            taken[item.index] = 1
            value += item.value
            weight += item.weight
            
    # prepare the solution in the specified output format
    output_data = str(value) + ' ' + str(0) + '\n'
    output_data += ' '.join(map(str, taken))
    return output_data, check_solution(capacity, items, taken)
# For each input file, solve_it is called and the result serialized in the ouputs for kaggle and moodle
str_output_kaggle = [["Filename","Max_value"]]
str_output_moodle = [["Filename","Max_value", "Solution"]]
for dirname, _, filenames in os.walk('/kaggle/input'):
    for filename in filenames:
        full_name = dirname+'/'+filename
        with open(full_name, 'r') as input_data_file:
            input_data = input_data_file.read()
            output, value = solve_it(input_data)
            str_output_kaggle.append([filename,str(value)])
            str_output_moodle.append([filename,str(value), output.split('\n')[1]])
from IPython.display import FileLink
def submission_generation(filename, str_output):
    os.chdir(r'/kaggle/working')
    with open(filename, 'w', newline='') as file:
        writer = csv.writer(file)
        for item in str_output:
            writer.writerow(item)
    return  FileLink(filename)
submission_generation('NAME_starter_kaggle.csv', str_output_kaggle)
# The file generated by this method must be uploaded in the task of the "campus virtual". The file to upload in the "campus virtual" must be the one related to one submitted to Kaggle. That is, both submitted files must be generated in the same run
submission_generation('NAME_starter_moodle.csv', str_output_moodle)
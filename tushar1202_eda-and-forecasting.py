# Importing required libraries

import numpy as np # linear algebra

import pandas as pd # data processing, CSV file I/O (e.g. pd.read_csv)



# Plotting Libraries

import seaborn as sns

import matplotlib.pyplot as plt





# settings

%matplotlib inline

import warnings

warnings.filterwarnings("ignore")
#  Fetching all the files in pandas dataframes

shops = pd.read_csv("/kaggle/input/competitive-data-science-predict-future-sales/shops.csv")

sales = pd.read_csv("/kaggle/input/competitive-data-science-predict-future-sales/sales_train.csv")

test = pd.read_csv("/kaggle/input/competitive-data-science-predict-future-sales/test.csv")

item = pd.read_csv("/kaggle/input/competitive-data-science-predict-future-sales/items.csv")

item_catg = pd.read_csv("/kaggle/input/competitive-data-science-predict-future-sales/item_categories.csv")

submission = pd.read_csv("/kaggle/input/competitive-data-science-predict-future-sales/sample_submission.csv")
sales.dtypes
print('training data has {} columns and {} rows'.format(sales.shape[1],sales.shape[0]))

print('test data has {} columns and {} rows'.format(test.shape[1],test.shape[0]))
#formatting the date column correctly

import datetime

sales.date=sales.date.apply(lambda x:datetime.datetime.strptime(x, '%d.%m.%Y'))
sales.head()
sales.describe()
test_only = test[~test['item_id'].isin(sales['item_id'].unique())]['item_id'].unique()

print('test only items:', len(test_only))
# dropping shops&items not in test data

shops_in_test = test.shop_id.unique()

items_in_test = test.item_id.unique()

sales = sales[sales.shop_id.isin(shops_in_test)]

sales = sales[sales.item_id.isin(items_in_test)]



print('sales:', sales.shape)
sales.head()
plt.figure(figsize=(10,4))

plt.xlim(-100, 3000)

sns.boxplot(x=sales.item_cnt_day)



plt.figure(figsize=(10,4))

plt.xlim(sales.item_price.min(), sales.item_price.max()*1.1)

sns.boxplot(x=sales.item_price)
sales = sales[sales.item_cnt_day<1000]
plt.figure(figsize=(10,4))

plt.xlim(-100, 3000)

sns.boxplot(x=sales.item_cnt_day)





plt.figure(figsize=(10,4))

plt.xlim(sales.item_price.min(), sales.item_price.max()*1.1)

sns.boxplot(x=sales.item_price)
## Checking the number of items sold per month

month_wise_items_sold = sales.groupby('date_block_num').agg({'item_cnt_day' : sum},inplace = True , reset_index = True)

plt.figure(figsize=(18,5))

plt.title('Items sold by the company')

plt.xlabel('Time')

plt.ylabel('Items sold')

plt.plot(month_wise_items_sold);
calculating_revenue = sales

calculating_revenue['revenue'] = calculating_revenue['item_price'] * calculating_revenue['item_cnt_day']

calculating_revenue.head()
## Checking the revenue generated by the company per month

month_wise_revenue = calculating_revenue.groupby('date_block_num').agg({'revenue' : sum})

plt.figure(figsize=(20,5))

plt.title('revenue generated per month by the company')

plt.xlabel('Time')

plt.ylabel('Revenue generated')

plt.plot(month_wise_revenue);
shop_wise_revenue = calculating_revenue.groupby('shop_id').agg({'revenue' : sum})

plt.figure(figsize=(20,5))

plt.title('revenue generated by the individual shops')

plt.xlabel('Shop id')

plt.ylabel('Revenue generated')

plt.plot(shop_wise_revenue);
## Checking number of returned items

returned_items = sales[sales['item_cnt_day'] < 0]

month_wise_items_returned = returned_items.groupby('date_block_num').agg({'item_cnt_day' : sum})

month_wise_items_returned['item_cnt_day'] = month_wise_items_returned['item_cnt_day'].abs()

plt.figure(figsize=(20,5))

plt.title('Items returned per month')

plt.xlabel('Time')

plt.ylabel('Items returned')

plt.plot(month_wise_items_returned);
timeseries = month_wise_items_sold 
plt.figure(figsize=(16,6))

plt.plot(timeseries.rolling(window=12,center=False).mean(),label='Rolling Mean');

plt.plot(timeseries.rolling(window=12,center=False).std(),label='Rolling sd');

plt.legend();
import statsmodels.api as sm



print('multiplicative model')

# multiplicative

mul_model = sm.tsa.seasonal_decompose(timeseries.values,freq=12,model="multiplicative")



fig = mul_model.plot()



# ------------------------------------------------------------------------------------

print('Additive model') 

# Additive

add_model = sm.tsa.seasonal_decompose(timeseries.values,freq=12,model="additive")



fig = add_model.plot()

# Stationarity tests

from statsmodels.tsa.stattools import adfuller, acf, pacf,arma_order_select_ic



def test_stationarity(timeseries):

    

    #Perform Dickey-Fuller test:

    print('Dickey-Fuller Test:')

    dftest = adfuller(timeseries, autolag='AIC')

    dfoutput = pd.Series(dftest[0:4], index=['Test Statistic','p-value','#Lags Used','Number of Observations Used'])

    for key,value in dftest[4].items():

        dfoutput['Critical Value (%s)'%key] = value

    print (dfoutput)



test_stationarity(timeseries)
# To remove trend

from pandas import Series as Series



# create a differenced series

def difference(dataset, interval=1):

    diff = list()

    for i in range(interval, len(dataset)):

        value = dataset[i] - dataset[i - interval]

        diff.append(value)

    return Series(diff)



# invert differenced forecast

def inverse_difference(last_ob, value):

    return value + last_ob
timeseries.columns
ts=sales.groupby(["date_block_num"])["item_cnt_day"].sum()

ts.astype('float')

plt.figure(figsize=(16,16))



plt.subplot(311)

plt.title('Original')

plt.xlabel('Time')

plt.ylabel('Sales')

plt.plot(ts)



plt.subplot(312)

plt.title('After De-trend')

plt.xlabel('Time')

plt.ylabel('Sales')

new_ts=difference(ts)

plt.plot(new_ts)

plt.plot()



plt.subplot(313)

plt.title('After De-seasonalization')

plt.xlabel('Time')

plt.ylabel('Sales')

new_ts=difference(ts,12)       # assuming the seasonality is 12 months long

plt.plot(new_ts)

plt.plot()
# now testing the stationarity again after de-seasonality

test_stationarity(new_ts)
# adding the dates to the Time-series as index

ts=sales.groupby(["date_block_num"])["item_cnt_day"].sum()

ts.index=pd.date_range(start = '2013-01-01',end='2015-10-01', freq = 'MS')

ts=ts.reset_index()

ts.head()
from fbprophet import Prophet



ts.columns=['ds','y']

#instantiate Prophet with only yearly seasonality as our data is monthly 

model = Prophet( yearly_seasonality=True) 

model.fit(ts) #fit the model with your dataframe
# predict for five months in the furure and MS - month start is the frequency

future = model.make_future_dataframe(periods = 5, freq = 'MS')  

# now lets make the forecasts

forecast = model.predict(future)

forecast[['ds', 'yhat', 'yhat_lower', 'yhat_upper']].tail()
model.plot(forecast)
model.plot_components(forecast)
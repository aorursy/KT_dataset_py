# -*- coding: utf-8 -*-
"""Extração das listas Spotify Charts.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1Hfxrwj39X-ewAXFIr7UFwXa0mryqRR5v

# Extração de dados do Spotify Charts

## Imports
"""

# install packages
!pip install spotipy

import requests
from requests.exceptions import BaseHTTPError
import io
import pandas as pd
import datetime
import spotipy
from tqdm import tqdm, trange
from spotipy.oauth2 import SpotifyClientCredentials

"""## Obtenção de Dados"""

# Gera as datas entre o intervalo definido para a extração das listas
start_date = datetime.datetime.strptime("01-01-2017", "%d-%m-%Y")
end_date = datetime.datetime.today() - datetime.timedelta(1)
days_delta = (end_date - start_date).days

list_date = [start_date + datetime.timedelta(n) for n in range(int(days_delta))]
list_date[:5]

def pandazize(date, tipo='regional'):
  # checa parâmetro 
  if tipo not in ('regional', 'viral'):
    raise ValueError(tipo)
        
  link = f'https://spotifycharts.com/{tipo}/br/daily/{str(date)[:10]}/download'
  header = 1 if tipo == 'regional' else 0
    
  response = requests.get(link)
  if response.ok:
    file_object = io.StringIO(response.content.decode('utf-8'))
    return pd.read_csv(file_object, header=header)
  else:
    return pd.DataFrame()

"""Obtém, através de uma requisição, a lista do chart `tipo` e de um determinado `date`"""

def tag_date(df, date):
  df['data_chart'] = str(date)[:10]
  df['data_chart_int'] = int(date.strftime('%Y%m%d'))
  return df

"""Marcamos as linhas com a sua respectiva data de referência

E ai, iteramos por todo o intervalo válido:
"""

from IPython.display import clear_output

tops = []
virals = []
pbar = tqdm(range(days_delta*2))

for (date, i) in zip(list_date, pbar):
  clear_output()
  pbar.set_description("Processing %s" % date.strftime('%Y-%m-%d'))
  for tipo in ['regional', 'viral']:
    current_chart = pandazize(date, tipo)
    current_chart = tag_date(current_chart, date)
    if tipo == 'regional':
      tops.append(current_chart)
    elif tipo == 'viral':
      virals.append(current_chart)

tops[-1].head(5)

"""Junta todos"""

df_top = pd.concat(tops)
df_viral = pd.concat(virals)
print(df_viral.shape)
print(df_top.shape)

"""Cria coluna de `track_id` para extração a partir da coluna `URL`:"""

df_top['URL'].iloc[0]

df_top['track_id'] = df_top['URL'].str.slice(start=31, stop=53, step=1)
df_viral['track_id'] = df_viral['URL'].str.slice(start=31, stop=53, step=1)
display(df_top.head(1))
display(df_viral.head(1))

"""## Enriquecimento com Propriedades das Faixas"""

client_id = 'xxxxxxxxxxxxxxxxxxxxxxxx' 
client_secret = 'xxxxxxxxxxxxxxxxxxxxxx'

client_credentials_manager = SpotifyClientCredentials(client_id=client_id,
                                                      client_secret=client_secret)
sp = spotipy.Spotify(client_credentials_manager=client_credentials_manager)

track_ids = pd.concat([df_top['track_id'], df_viral['track_id']]).unique()
feature = []

for track in track_ids:
    track_feature = sp.audio_features(track)
    # audio_features retorna uma lista, portanto usamos extend()
    feature.extend(track_feature)

"""Transforma lista em um DataFrame para possibilitar a exportação para .csv"""

df_feature = pd.DataFrame(feature,columns=['danceability', 'energy', 'key', 'loudness', 'mode', 'speechiness', 'acousticness', 'instrumentalness', 'liveness', 'valence', 'tempo', 'type', 'id', 'uri', 'track_href', 'analysis_url', 'duration_ms', 'time_signature'])

"""Persiste os dados extraidos em formato csv"""

df_top.to_csv(r'df_top.csv', index = True)
df_viral.to_csv(r'df_viral.csv', index = False)
df_feature.to_csv('features.csv', index = False)


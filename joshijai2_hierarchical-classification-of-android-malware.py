import numpy as np # linear algebra
import pandas as pd # data processing, CSV file I/O (e.g. pd.read_csv)

import matplotlib.pyplot as plt
import seaborn as sns

from sklearn.preprocessing import StandardScaler, LabelEncoder

from sklearn.model_selection import train_test_split

from sklearn.manifold import TSNE

from imblearn.over_sampling import SMOTE, SVMSMOTE

seed= 42
# ! pip install sklearn_hierarchical_classification
# import sklearn_hierarchical_classification.classifier as shclf
df = pd.read_csv("../input/andmal-prep/andmal_prep.csv")
# df = pd.read_csv("../input/andmal2020cdmc/AndroidMalware_Training_set.csv", header=None)
df.shape
df.info()
df.head(10)
df.info()
plt.xticks(rotation = 90)
sns.countplot(df.Category)
fam_counts = df.Family.value_counts()
fam_counts
#identify low malware family counts
low_fam = fam_counts[fam_counts==1]
low_fam.count()
#removing low malware family counts
# df = df[df[2494].apply(lambda x: x not in low_fam.index)]
# df.shape
#separating features and target
y = df[['Category','Family']]
X = df.drop(['Category','Family'],1)
print('Features shape:', X.shape)
print('Target shape:', y.shape)
y.Category.value_counts()
d={'Riskware': 16977, 'Adware': 8134, 'Trojan': 2398, 'Ransomware': 1093, 'Spyware': 617, 'SMS': 617, 'Dropper': 617, 'PUA': 617, 'Backdoor': 287, 'Scareware': 287, 'Banker': 287, 'FileInfector': 287}
oversampler = SMOTE(sampling_strategy=d, n_jobs=-1, random_state=42)
X_smote, y_smote_cat = oversampler.fit_resample(X, y.Category)
!pip install sklearn-deap
from evolutionary_search import EvolutionaryAlgorithmSearchCV
from sklearn.model_selection import cross_val_score
from sklearn.metrics import classification_report, confusion_matrix
from imblearn.over_sampling import RandomOverSampler

from joblib import dump, load
from sklearn.pipeline import make_pipeline
from sklearn.linear_model import LogisticRegression
from sklearn.ensemble import RandomForestClassifier, GradientBoostingClassifier, StackingClassifier
from xgboost import XGBClassifier
from lightgbm import LGBMClassifier
#helper function

# evaluate the models and store results for oversampled minority class
def evaluate_models(models, xtrain, ytrain, cv=3, output=True):
    results, names = list(), list()
    for name, model in models.items():
        scores = cross_val_score(model, xtrain, ytrain, scoring='accuracy', cv=cv, n_jobs=-1,verbose=1)
        results.append(scores)
        names.append(name)
        if output:
            print('*%s %.3f (%.3f)' % (name, scores.mean(), scores.std()))
    return names, results

# Hyperparameter Optimization using EvolutionaryAlgorithmSearchCV
def evaluate_params(models, xtrain, ytrain, param_grids, cv=3, output=True):
    best_params = param_grids
    names= list(param_grids.keys())
    for name, param_grid, model in zip(param_grids.keys(), param_grids.values(), models.values()):
        eascv = EvolutionaryAlgorithmSearchCV(model, param_grid, verbose=5, cv=cv)
        eascv.fit(xtrain,ytrain)
        best_params[name] = eascv.best_params_
        if output:
            print(name)
            print("best score:",eascv.best_score_)
            print("best params:",eascv.best_params_)
    return names, best_params
X_train, X_test, y_train, y_test = train_test_split(X_smote, y_smote_cat, test_size=0.4, random_state=42, stratify=y_smote_cat)
#standardization of features
scaler = StandardScaler()
X_train = scaler.fit_transform(X_train)
X_test = scaler.transform(X_test)

#encoding category
le_cat = LabelEncoder()
y_train = le_cat.fit_transform(y_train)
y_test = le_cat.transform(y_test)
models = {
#     'GB':GradientBoostingClassifier(random_state=seed),
    'RF':RandomForestClassifier(n_jobs=-1, random_state=seed),
#     'XGB':XGBClassifier(n_jobs=-1, random_state=seed),
    'LGBM':LGBMClassifier(n_jobs=-1, random_state=seed)
    }
names, results = evaluate_models(models, X_train, y_train)
plt.boxplot(results, labels=names, showmeans=True)
plt.show()
for name, model in models.items():
    print(name,'parameters:')
    print(model.get_params())
    print('='*140)
RF = RandomForestClassifier(n_estimators=1000, n_jobs=-1, random_state=seed)
RF.fit(X_train, y_train)
LGBM = LGBMClassifier(n_estimators=750, subsample=0.9, num_leaves=50, n_jobs=-1, random_state=seed)
LGBM.fit(X_train, y_train)
# XGB = XGBClassifier(max_depth=20, n_estimators=500, learning_rate=0.05, subsample=0.5, n_jobs=-1, random_state=seed) 
# XGB.fit(X_train, y_train)
print(RF.score(X_test, y_test))
print(LGBM.score(X_test, y_test))
# print(XGB.score(X_test, y_test))
dump(LGBM,"Parent_Classifier.joblib")
df.groupby(['Category','Family']).count()
y.Family.value_counts()
# le_fam = LabelEncoder()
# y = le_fam.fit_transform(y)
X_train, X_test, y_train, y_test = train_test_split(X, y, test_size=0.3, random_state=42, stratify=y.Category)
Cats = dict()
for cat in y.Category.unique():
    Cats[cat] = X_train.join(y_train)[y_train.Category==cat]
Cats.keys()

subclf = {'Riskware': make_pipeline(StandardScaler(),XGBClassifier(n_jobs=-1, random_state=seed)),
 'Adware': make_pipeline(StandardScaler(),XGBClassifier(n_jobs=-1, random_state=seed)),
 'Trojan': make_pipeline(StandardScaler(),XGBClassifier(n_jobs=-1, random_state=seed)),
 'Ransomware': make_pipeline(StandardScaler(),XGBClassifier(n_jobs=-1, random_state=seed)),
 'Spyware': make_pipeline(StandardScaler(),XGBClassifier(n_jobs=-1, random_state=seed)),
 'SMS': make_pipeline(StandardScaler(),XGBClassifier(n_jobs=-1, random_state=seed)),
 'Dropper': make_pipeline(StandardScaler(),LogisticRegression(n_jobs=-1)),
 'PUA': make_pipeline(StandardScaler(),LogisticRegression(n_jobs=-1)),
 'Backdoor': make_pipeline(StandardScaler(),LogisticRegression(n_jobs=-1)),
 'Scareware': make_pipeline(StandardScaler(),LogisticRegression(n_jobs=-1)),
 'Banker': make_pipeline(StandardScaler(),LogisticRegression(n_jobs=-1)),
 'FileInfector': make_pipeline(StandardScaler(),LogisticRegression(n_jobs=-1))}
les={'Riskware': LabelEncoder(),
 'Adware': LabelEncoder(),
 'Ransomware': LabelEncoder(),
 'Banker': LabelEncoder(),
 'Dropper': LabelEncoder(),
 'Spyware': LabelEncoder(),
 'Trojan': LabelEncoder(),
 'SMS': LabelEncoder(),
 'Scareware': LabelEncoder(),
 'PUA': LabelEncoder(),
 'Backdoor': LabelEncoder(),
 'FileInfector': LabelEncoder()}
for cat in Cats.keys():
    Cats[cat]['Family']
    subclf[cat].fit(Cats[cat].drop(['Category', 'Family'],1),les[cat].fit_transform(Cats[cat]['Family']))

def Hierarchical_classifier(X_test):
    preds = []
    Parent_clf = load("Parent_Classifier.joblib")
    for x in X_test:
        cat_pred = le_cat.inverse_transform(Parent_clf.predict(x))
        mal_pred = les[cat_pred].inverse_transform(subclf[cat_pred].predict(x))
        preds.append([cat_pred,mal_pred])
    return preds
        
